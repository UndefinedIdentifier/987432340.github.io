title: 异常分发过程笔记
layout: post
date: 2016-05-06 21:06:10
categories: 读书笔记
tags: [内核,异常]
---


当异常发生时，CPU会通过IDT表找到相应的**KiTrapxxx**异常处理函数执行。但是，KiTrapxxx只是对异常做简单的封装描述，并不帮我们直接解决了异常。因为异常也可以用来改变程序的执行流，这取决于程序员怎么去处理(利用)这个异常。

<!--more-->



所以，一方面为了支持调试，另一方面为了支持软件自定义的异常处理函数，OS需要将异常分发出来，分发给调试器以及程序本身的SEH。

异常分为CPU异常、软件异常，但是windows采用统一的方式来分发异常。

# 一、KiDispatchException

原型

```cpp
 VOID
  KiDispatchException (
      IN PEXCEPTION_RECORD ExceptionRecord,		//异常结构，描述要分发的异常
      IN PKEXCEPTION_FRAME ExceptionFrame,		//对于x86系统为NULL
      IN PKTRAP_FRAME TrapFrame,				//指向KTRAP_FRAME结构，描述异常发生时处理器状态
      IN KPROCESSOR_MODE PreviousMode,			//触发异常代码的执行模式，0内核模式，1用户模式
      IN BOOLEAN FirstChance					//第几次处理机会
      );
```



KiDispatchException函数会先调用**KeContextFromKframes**函数，目的是根据TrapFrame参数指向的KTRAP_FRAME结构产生一个**CONTEXT**结构，用来向调试器和SEH报告异常。接下来就会根据PreviousMode参数选择内核态异常分发还是用户态异常分发。

# 二、内核态

因为每个处理流程返回T都直接返回，所以画图默认每个流程都是返回false。

![](http://7xn4yz.com1.z0.glb.clouddn.com/Sample%20Flowchart%20Template.png)

## 三、用户态



##### 步骤0: 满足2个条件发送给内核调试器

一般不用考虑这步。异常是否是内核调试器触发  **and** 内核调试器是否接受用户态异常（windbg 的/noumex选项为不接受用户态异常）

##### 步骤1: 第一轮处理机会

调用用户态调试子系统内核函数**DbgkForwardException(异常结构，TRUE，FALSE)**，目的是将异常发送给用户态调试器。参数2是执行发送给调试端口还是异常端口；参数3是指定是否是第二轮处理机会。

DbgkForwardException检查DebugPort不为空，则继续调用**DbgkSendApiMessage**将异常发送给调试子系统，子系统通知调试器，如果DbgkSendApiMessage返回成功，说明处理了该异常，异常分发结束，失败则继续。

调试器处理不了则寻找执行SEH，SEH位于用户态，所以得先返回用户态。内核变量KiUserExceptionDispatcher记录了用户态中的异常分发函数，指向了NTDLL!KiUserExceptionDispatcher函数。虽然对于用户态异常、CPU异常对应有不同的调整执行流程的方式，总之都跳到了用户态的**KiUserExceptionDispatcher**函数开始执行。

KiUserExceptionDispatcher会调用**RtlDispatchException**遍历执行SEH，如果执行完所有已注册SEH还没处理这个异常，系统最后有个默认的SEH。这个SEH会执行UnhandledExceptionFilter函数，这个函数返回false。

KiUserExceptionDispatcher会发起对这个异常的第二轮分发。具体是调用**ZwRaiseException**，并将FirstChange参数设为FALSE。

##### 步骤2:  第二轮处理机会

调用用户态调试子系统内核函数**DbgkForwardException**，标明第二次处理机会。返回false继续。

调用用户态调试子系统内核函数**DbgkForwardException**，标明异常端口。目的是将异常发送给进程的ExcepitionPort，并且这里的DbgkSendApiMessage不会挂起当前进程。

如果最后这次还是返回false，KidispatchException会终止当前线程。
