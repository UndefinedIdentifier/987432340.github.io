title: DexHunter学习笔记2
layout: post
date: 2016-04-28 01:39:11
categories: 移动安全
tags: [dalvik, 脱壳]
---


DexHunter的文件重组方法现在应该是市面上通杀，趁着这两天状态不错的时候，赶紧来学习一发。主要参考[乌云上的这篇文章](http://drops.wooyun.org/tips/9335)。

# 还没分析完~
<!--more-->


作者在**开始修改**部分说到：

> 对于之前提到的入口函数，都有一个参数表示在操作的文件。
>
> DVM中是DexOrJar，相对的字符串成员是fileName。这下我们就好整了，只要我们指定了目标字符串，我们就可以从可能使用的众多dex文件中找出我们想要的那个，而且方便的是，通过这两个对象，我们还能很容易找到操作的文件在内存中的起始地址和长度。



之前提到的入口函数也就是



> 在DVM中：
>
> 显式加载：
>
> ClassLoader.loadClass对应Dalvik_dalvik_system_DexFile_defineClassNative
>
> Class.forName对应Dalvik_java_lang_Class_classForName
>
> 隐式加载：
>
> 对应dvmResolveClass



搜索到`dalvik/vm/native/dalvik_system_DexFile.cpp`，来到Dalvik_dalvik_system_DexFile_defineClassNative函数中查看，的确是找到了有DexOrJar这个结构。

```cpp
DexOrJar* pDexOrJar = (DexOrJar*) cookie;
```



查看一下比原文件多出了哪些内容？



​	作者改的时候在Dalvik_dalvik_system_DexFile_defineClassNative函数上下分别加了一段代码，而且做了分隔区域。



找到这个DexOrJar的定义

```cpp
/*
 * Internal struct for managing DexFile.
 */
struct DexOrJar {
    char*       fileName;	// 我们通过这个字段筛选出要处理的dex文件
    bool        isDex;		
    bool        okayToFree;
    RawDexFile* pRawDexFile;
    JarFile*    pJarFile;
    u1*         pDexMemory; // malloc()ed memory, if any
};
```

`Q1:起始地址和内存是怎么确定的？`



作者在Dalvik_dalvik_system_DexFile_defineClassNative函数中添加的的代码位于原文件的378行之后的位置。为什么在这儿呢？因为在这里，刚刚好是原代码拿到 pDvmDex结构的位置，后面的很多操作都是基于这个pDvmDex

```cpp
/*
	通过pDexOrJar抓取到pDvmDex结构
*/
370    if (pDexOrJar->isDex)
371        pDvmDex = dvmGetRawDexFileDex(pDexOrJar->pRawDexFile);	
372    else
373        pDvmDex = dvmGetJarFileDex(pDexOrJar->pJarFile);
```



接着开启一个读线程，这个线程函数就是在Dalvik_dalvik_system_DexFile_defineClassNative函数上添加的一部分代码。

```cpp
1021   pthread_create(&read_thread, NULL, ReadThread, NULL);
```

ReadThread做的事是打开一个`/data/dexname`文件，读取文件给dexname，dumppath赋值。接着匹配字符串，看是否是我们要处理的dex文件

```cpp
strstr(pDexOrJar->fileName, dexname);
```

赋值

```cpp
DvmDex* pDvmDex;
DexFile* pDexFile=pDvmDex->pDexFile;
MemMapping * mem=&pDvmDex->memMap;
```



```cpp
/*
 * Some additional VM data structures that are associated with the DEX file.
 * 关联着dex文件的一些额外的虚拟机结构
 */
struct DvmDex {
    /* pointer to the DexFile we're associated with */
    DexFile*            pDexFile;

    /* clone of pDexFile->pHeader (it's used frequently enough) */
    const DexHeader*    pHeader;

    /* interned strings; parallel to "stringIds" */
    struct StringObject** pResStrings;

    /* resolved classes; parallel to "typeIds" */
    struct ClassObject** pResClasses;

    /* resolved methods; parallel to "methodIds" */
    struct Method**     pResMethods;

    /* resolved instance fields; parallel to "fieldIds" */
    /* (this holds both InstField and StaticField) */
    struct Field**      pResFields;

    /* interface method lookup cache */
    struct AtomicCache* pInterfaceCache;

    /* shared memory region with file contents */
    bool                isMappedReadOnly;
    MemMapping          memMap;					//文件在内存中的映射？

    jobject dex_object;

    /* lock ensuring mutual exclusion during updates */
    pthread_mutex_t     modLock;
};
```



开始dump 2段数据

```cpp
// dump第一段数据
const u1 *addr = (const u1*)mem->addr;
/*
	baseAddr: points to start of DEX file data 
*/
int length=int(pDexFile->baseAddr+pDexFile->pHeader->classDefsOff-addr);
fwrite(addr,1,length,fp);
// dump第二段数据
addr = pDexFile->baseAddr+pDexFile->pHeader->classDefsOff+sizeof(DexClassDef)*pDexFile->pHeader->classDefsSize;
length=int((const u1*)mem->addr+mem->length-addr);
fwrite(addr,1,length,fp);
```

开启dumpclass线程之后，这段代码就结束了。

```cpp
param.loader=loader;
param.pDvmDex=pDvmDex;
// 这个线程是dvm自己实现的
dvmCreateInternalThread(&dumpthread,"ClassDumper",DumpClass,(void*)&param);
```

线程函数是DumpClass，