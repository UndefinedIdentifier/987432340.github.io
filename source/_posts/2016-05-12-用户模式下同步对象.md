title: 用户模式下同步对象
layout: post
date: 2016-05-12 14:18:57
categories: 读书笔记
tags: 驱动
---



在内核模式可用很多的内核同步对象，事件（Event）、互斥体（Mutex）、信号灯（Semaphore）等。这些对象和用户模式下的同步对象非常相似，用户模式下的同步对象都是对内核模式下的同步对象再封装。

下一节内核模式同步对象先学习用户模式下的同步。
<!--more-->


## 1. 用户模式等待

在应用程序中，可以用WaitForSingleObject、WaitForMutipleObjects等待同步对象。其中WaitForSingleObject等待一个同步对象，而WaitForMutipleObjects等待多个同步对象。WaitForSingleObject声明：

```cpp
DWORD WaitForSingleObject( 
HANDLE hHandle,				//同步对象句柄
DWORDdwMilliseconds			//等待时间
);
```

同步对象有2种状态，signal有信号，无信号。如果对象无信号，则等待多长时间，这个时间也可以无限长（痴情的男子）直到等到为止。

WaitForMutipleObjects声明：

```cpp
DWORD WINAPI WaitForMultipleObjects(
  _In_       DWORD  nCount,			//同步对象数组元素个数
  _In_ const HANDLE *lpHandles,		//同步对象数组指针
  _In_       BOOL   bWaitAll,		//是否等待所有同步对象
  _In_       DWORD  dwMilliseconds	//等待时间
);

```

bWaitAll为真，则等待所有同步对象；为假等到一个对象就不等待了。



## 2. 用户模式事件

形如**APICreateXXX**的API，如果第一个参数是lp安全属性，那么这种API内部都会创建一个相应的内核对象，应用程序无法这个内核时间对象的指针，但系统通过API返回的句柄可以找到具体的内核对象。

事件是典型的同步对象。初始化/创建一个事件：

```cpp

HANDLE WINAPI CreateEvent(
  _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,
  _In_     BOOL                  bManualReset,		//是否手动
  _In_     BOOL                  bInitialState,		//初始状态
  _In_opt_ LPCTSTR               lpName				//命名
);

```



使用同步事件的多线程

![](http://7xn4yz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-12%20%E4%B8%8B%E5%8D%8812.36.19.png)

## 3. 用户模式信号灯

信号灯也是一种常见的同步对象，信号灯也有两种状态，一种是有信号，另一种是无信号状态。信号灯内部有个计数器，可以理解信号灯内部有N个灯泡。如果有一个灯泡亮着，就代表信号灯处于激发状态，如果全部熄灭，则代表信号灯处于未激发状态。我理解为相当于一个并联电路，一路同则灯亮。

使用信号灯前需要先创建信号灯，CreateSemaphore函数负责创建信号灯。它的声明如下：

```cpp
HANDLE
CreateSemaphoreA(
    IN LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,	// 安全属性
    IN LONG lInitialCount,							// 初始化计数个数
    IN LONG lMaximumCount,							// 计数器最大个数
    IN LPCSTR lpName								// 命名
    );
```

其中，第二个参数lInitialCount在指明初始化时，计数器的值为多少。

第三个参数lMaximumCount指明该信号灯计数器的最大值是多少。如果初始值为0，则处于无信号状态；如果初始值为非零，则处于有信号状态。

另外，可以使用期ReleaseSemaphore函数增加信号灯的计数器，其函数声明如下：

```cpp

BOOL WINAPI ReleaseSemaphore(
  _In_      HANDLE hSemaphore,
  _In_      LONG   lReleaseCount,		//这次要增加计数数量
  _Out_opt_ LPLONG lpPreviousCount		//保存增加前的数量
);
```

对信号灯执行一次等待，就会减少一个计数。当计数为0，当前线程进入睡眠，知道信号变为有信号。

使用信号灯多线程同步

```cpp
UINT WINAPI Thread(LPVOID para)
{
	printf("Enter Thread1\n");
	HANDLE *phSemaphore = (HANDLE*)para;
	// 等待5s
	Sleep(5000);
	printf("Leave Thread1\n");
	// 将信号灯计数器加1，使之处于激发状态
	ReleaseSemaphore(*phSemaphore, 1, NULL);
	return 0;
}

int main()
{
	// 创建同步事件
	HANDLE hSemaphore = CreateSemaphore(NULL, 2, 2, NULL);
	// 此时信号灯计数为2， 处于触发状态
	WaitForSingleObject(hSemaphore, INFINITE);
	// 此时的信号灯计数为1，处于触发状态
	WaitForSingleObject(hSemaphore, INFINITE);
	// 此时的信号灯计数为0， 处于未触发状态
	// 开启新线程，并将同步事件句柄指针传给新线程
	HANDLE hThread1 = (HANDLE)_beginthreadex(NULL, 0, Thread1, &hSemaphore, 0, NULL);
	// 等待事件激发
	WaitForSingleObject(hSemaphore, INFINITE);
}
```



## 4. 用户模式下的互斥体

互斥避免多个线程争夺同一个资源。

创建互斥体：



```cpp
HANDLE CreateMutex(

LPSECURITY_ATTRIBUTES lpMutexAttributes, // pointer to security attributes
BOOL bInitialOwner,  // flag for initial ownership
LPCTSTR lpName       // pointer to mutex-object name
);
```

  

释放互斥体：

```cpp
BOOL ReleaseMutex(
  HANDLE hMutex   // handle to mutex object
);
```

使用互斥体

```cpp
#include <windows.h>
#include <process.h>
#include <stdio.h>
 
UINT WINAPI ThreadProc1(LPVOID lparam)
{
         HANDLE hMutex = *(PHANDLE)lparam;
         //等待互斥体
         WaitForSingleObject(hMutex, INFINITE);
         //对于同一个线程,已经获得了互斥体,还可以多次获取
         WaitForSingleObject(hMutex, INFINITE);
         printf("Enter  Thread1!\n");
         Sleep(2000);
         printf("Leave  Thread1!\n");
         //释放互斥体
         ReleaseMutex(hMutex);
         return 0;
}

UINT WINAPI ThreadProc2(LPVOID lparam)
{       
         HANDLE hMutex = *(PHANDLE)lparam;
         WaitForSingleObject(hMutex, INFINITE);
         printf("Enter  Thread2!\n");
         Sleep(2000);
         printf("Leave  Thread2!\n");
         ReleaseMutex(hMutex);
         return 0;

}

int main(void)
{
         printf("Enter Main Thread!\n");
         //创建互斥体
         HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);
         HANDLE hThread1 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc1, &hMutex, 0, NULL);
         HANDLE hThread2 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc2, &hMutex, 0, NULL);
         Sleep(6000);
         printf("Leave Main Thread!\n");
         return 0;
}
```

## 5. 等待线程完成

主要使用 WaitForSingleObject、**WaitForMultipleObjects**等待

```cpp
#include <windows.h>
#include <stdio.h>
#include <process.h>

UINT WINAPI ThreadProc(LPVOID lpParam)
{
         printf("Enter ThreadProc!\n");
         Sleep(5000);
         printf("Leave ThreadProc!\n");
         return 0;
}

int main(void)
{
         //创建两个字线程
         HANDLE hThread1 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc, NULL, 0, NULL);
         HANDLE hThread2 = (HANDLE)_beginthreadex(NULL, 0, ThreadProc, NULL, 0, NULL);
         //主线程等待两个字线程结束
         HANDLE hThread[2] = {hThread1, hThread2};
         WaitForMultipleObjects(2, hThread, TRUE, INFINITE);
         return 0;
}
```

