title: 通用脱壳思路学习
layout: post
date: 2016-04-28 01:50:47
categories: 移动安全
tags: [dalvik, 脱壳]
---

通用脱壳思路学习乌云上的一篇文章

# 未完待续
<!--more-->


修改源码`dalvik/vm/mterp/out/InterpC-portable.cpp`文件中的

> 在Dalvik解释执行的每条指令切换处
>
> 这样可以在执行过程中的任意指令处进行脱壳的操作，一边应对边运行边解密的加固程序。

也就是说一边正常运行、一边进行记录执行了哪些指令。

下载INDROID的`InterpC-portable.cpp`源码和原始的4.2源码对比发现一处可疑的地方,代码很有趣，杨博士的个人自黑

```
#ifdef LOCCS_DIAOS		
# define FINISH(_offset) {                                                  \
		diaos_monitor_opcode( pc, fp, self, curMethod );					\
        ADJUST_PC(_offset);                                                 \
        inst = FETCH(0);                                                    \
        if (self->interpBreak.ctl.subMode) {                                \
            dvmCheckBefore(pc, fp, self);                                   \
        }                                                                   \
        goto *handlerTable[INST_INST(inst)];                                \
    }
#else				
# define FINISH(_offset) {                                                  \
        ADJUST_PC(_offset);                                                 \
        inst = FETCH(0);                                                    \
        if (self->interpBreak.ctl.subMode) {                                \
            dvmCheckBefore(pc, fp, self);                                   \
        }                                                                   \
        goto *handlerTable[INST_INST(inst)];                                \
    }
#endif
```



好了进入正题，从InterpC-portable.cpp这个文件入手来学习通用脱壳。[这篇文章](http://bbs.pediy.com/showthread.php?t=203627)写了dalvik的解释执行流程，可以作为参考加快学习进度。

> dalvik真正对指令解析是从dvmInterpretPortable(Thread* self)函数开始



dvmInterpretPortable 函数的局部变量

```
    DvmDex* methodClassDex;     // curMethod->clazz->pDvmDex 从当前方法找到所在类，再进一步找到dex
    JValue retval;				
/* core state */ 				//最核心的状态
    const Method* curMethod;    // method we're interpreting	当前解释执行的方法
    const u2* pc;               // program counter
    u4* fp;                     // frame pointer 简单来说fp相当于ebp，参考fp指针链接
    u2 inst;                    // current instruction 当前指令
/* instruction decoding */		//指令解码
    u4 ref;                     // 16 or 32-bit quantity fetched directly
    u2 vsrc1, vsrc2, vdst;      // usually used for register indexes
    /* method call setup */		//方法调用建立
    const Method* methodToCall;	
    bool methodCallRange;
```

[fp指针](http://blog.chinaunix.net/uid-25871104-id-2938389.html)

关于上面的

> 在指令执行时可以直接得到该条指令属于的方法，Method这个结构。
>
> 而每个被执行的方法中都有该方法属于的类对象clazz，而clazz（源码目录dalvik/vm/oo/Object.h）中又有pDvmDex（dalvik/vm/DvmDex.h）对象，其中有pDexFile（dalvik/libdex/DexFile.h）结构体代表了DEX文件，也就是说，执行过程中获取当前方法后，用
>
> curMethod->clazz->pDvmDex->pDexFile就能够得到这个方法属于的DEX文件结构



指令宏定义

```
DEFINE_GOTO_TABLE(handlerTable);		//这实际是一个宏

//定义在dalvik/libdex/DexOpcodes.h

334#define DEFINE_GOTO_TABLE(_name) \
335    static const void* _name[kNumPackedOpcodes] = {                      \
336        /* BEGIN(libdex-goto-table); GENERATED AUTOMATICALLY BY opcode-gen */ \
337        H(OP_NOP),                                                            \
338        H(OP_MOVE),                                                           \
339        H(OP_MOVE_FROM16),                                                    \
//	下面的就省略了	
所以展开相当于
handlerTable[kNumPackedOpcodes] = {
	H(OP_NOP),
	H(OP_MOVE),  
	H(OP_MOVE_FROM16), 
	……
	}
//而在dalvik/vm/mterp/out/InterpC-portable.cpp中又H()宏的定义
# define H(_op)     &&op_##_op
// ## 进行参数连接
// &&相当于对后面的标号取地址
// H(OP_NOP) 经过宏展开成 &&op_OP_NOP
// 而 &&op_OP_NOP是相当于标号op_OP_NOP，利用goto语句
// goto &&op_OP_NOP即可到达标号op_OP_NOP

```

取指令

````
FINISH(0); 
// 同样是宏 
415# define FINISH(_offset) {                                                  \
416        ADJUST_PC(_offset);                                                 \
417        inst = FETCH(0);                                                    \
418        if (self->interpBreak.ctl.subMode) {                                \
419            dvmCheckBefore(pc, fp, self);                                   \
420        }                                                                   \
421        goto *handlerTable[INST_INST(inst)];                                \
422    }

//对于ADJUST_PC，应该就是调整PC指针的值，加垃圾代码在分支编译一下试试能过则说明走的另一分支

105#ifdef CHECK_BRANCH_OFFSETS
106# define ADJUST_PC(_offset) do {                                            \
107        int myoff = _offset;        /* deref only once */                   \
108        if (pc + myoff < curMethod->insns ||                                \
109            pc + myoff >= curMethod->insns + dvmGetMethodInsnsSize(curMethod)) \
110        {                                                                   \
111            char* desc;                                                     \
112            desc = dexProtoCopyMethodDescriptor(&curMethod->prototype);     \
113            ALOGE("Invalid branch %d at 0x%04x in %s.%s %s",                 \
114                myoff, (int) (pc - curMethod->insns),                       \
115                curMethod->clazz->descriptor, curMethod->name, desc);       \
116            free(desc);                                                     \
117            dvmAbort();                                                     \
118        }                                                                   \
119        pc += myoff;                                                        \
120        EXPORT_EXTRA_PC();                                                  \
121    } while (false)
122#else
123# define ADJUST_PC(_offset) do {                                            \
124        pc += _offset;                                                      \
125        EXPORT_EXTRA_PC();                                                  \
126    } while (false)
127#endif

// INST_INST(inst) 宏获取单字节的指令

#define INST_INST(_inst)    ((_inst) & 0xff)

//比如此时字节码值为0，那么goto *handlerTable[INST_INST(inst)]就是goto op_OP_NOP

````



----



### 修改模拟器以portable方式执行

手上虽然有真机，但是每次修改源码再刷到手机有点麻烦，而且费时。如果使用模拟器，编译好的镜像直接可以拿来用。考虑到这一点，决定先在模拟器上进行试验，让模拟器以protable的方式进行执行。整个过程不难，但是有点折腾，搞好了有点小成就感。



直接搜索修改dalvik为解释执行模式，找到下面3个有用信息：

> The fast interpreter is enabled by default. On platforms without native support, you may want to switch to the portable interpreter. This can be controlled with the`dalvik.vm.execution-mode` system property. For example, if you:
>
> `adb shell "echo dalvik.vm.execution-mode = int:portable >> /data/local.prop"`

还有人说在

> 文件夹system/build.prop或者 data/local.prop  

结合

```
在Android系统中，有一些初始化的配置文件，例如:
/init.rc
/default.prop
/system/build.prop
文件里面里面配置了开机设置的系统属性值，
这些属性值，可以通过getprop获取，setprop设置
```



​	然而我再模拟器中没有/data/local.prop文件，找到了/system/build.prop这文件。当我想`adb pull/push`这个文件时，提示文件只读，一脸蒙蔽。

找到[stackoverflow](http://stackoverflow.com/questions/6066030/read-only-file-system-on-android)上的解答，最简单的方法

```
chris@cc:~/android-4.3_r1$ adb push build.prop /system
failed to copy 'build.prop' to '/system/build.prop': Read-only file system
chris@cc:~/android-4.3_r1$ adb remount
remount succeeded
chris@cc:~/android-4.3_r1$ adb push build.prop /system
37 KB/s (1700 bytes in 0.043s)
```

这时候，一般情况下应该就成功了，但是，可能因为又是电脑比较渣，上面的操作也不会成功。

遇到的错误是out of memory.

然后再找原因，是我以默认方式启动模拟器时，模拟器内存不够了，指定一下就好了。

```
emulator -partition-size 512
```

现在也能改文件的配置了，按说就能改执行模式了吧！？一脸蒙蔽的事情又来了，dalvik虚拟机的启动是在开机的时候，所以这里我们需要重启模拟器，然而adb reboot之后，增加了机器的轰鸣声，但是模拟器还是一直没重启，要哭瞎了有没有。

可是我们是有安卓源码，只要改掉默认的启动选项就好了。根据老罗对安卓源码的分析，这个文件位于`frameworks/base/core/jni/AndroidRuntime.cpp`，我们修改一处地方即可。

```
    if (executionMode == kEMIntPortable) {  
        opt.optionString = "-Xint:portable";  
        mOptions.add(opt);  
    } else if (executionMode == kEMIntFast) {  
        opt.optionString = "-Xint:fast";  
        mOptions.add(opt);  
    } else if (executionMode == kEMJitCompiler) {  
        opt.optionString = "-Xint:jit";  
        mOptions.add(opt); 
    }
    // my add 
       opt.optionString = "-Xint:portable";  
       mOptions.add(opt); 
    //*******后面创建虚拟器会读取这里的配置************
```

重新编译源码，模拟器用新的system.img就会以portable方式执行。为了验证是否以portable执行，我们修改`dalvik/vm/mterp/out/InterpC-portable.cpp`，添加一行PPP代码，再次编译。

```
#define PPP(...) ALOG(LOG_VERBOSE,"LYJ",__VA_ARGS__)

# define FINISH(_offset) {                                                  \
		PPP("LYJ","xxxxxxxxxx");											\
        ADJUST_PC(_offset);                                                 \
        inst = FETCH(0);                                                    \
        if (self->interpBreak.ctl.subMode) {                                \
            dvmCheckBefore(pc, fp, self);                                   \
        }                                                                   \
        goto *handlerTable[INST_INST(inst)];                                \
    }
```

启动模拟器后，我们用logcat查看一下，不断输出这条log，说明我们改portable成功。

```
adb logcat -s LYJ
V/LYJ     (  277): xxxxxxxxxx
```

-----

