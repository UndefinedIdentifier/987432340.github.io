title: DexHunter学习笔记1
categories: 移动安全
tag: [dalvik, 脱壳]
date: 2015-11-13 15:56:12
---

这个分析是比较早些时候写的，切入点比较浅。

基于修改android源码的自动脱壳机，可以自动脱了dex的壳，早就说过dex层藏不住东西。这样，所有的安全保护的重点就应该放在native层上。有源码跟着学习一下自动脱壳.android源码的版本基于4.3，和我的代码版本刚好一样（如果没有源码的童靴，android SDK更新的时候获取相应版本的源码,也可以选择国内的镜像源获取源码）。我进行学习的是dalvik相关所以主要关注雨dalvik目录，art以后再说吧。

<!--more-->
**原帖地址 ** [Android dex文件通用自动脱壳器](http://bbs.pediy.com/showthread.php?t=203776)

**源码** [github地址](https://github.com/zyq8709/DexHunter)

##### 学习思路

建立git仓库，把原始的源码传上去作为第一个版本。查看作者的更新历史，比较文件的不同处，一步一步注释第一个版本的源码进行学习。把这个过程搞清楚了，再去操作一下自动脱壳。

----

DexHunter第一个有源码的版本[DexHunter1](https://github.com/zyq8709/DexHunter/tree/768fcdc64b89ce468b6f751b0eb124d24e3cde0a)

### ReadMe

主要修改了 "dalvik/vm/native/dalvik_system_DexFile.cpp" (DVM).

脱壳app的步骤：

1. 在启动app之前push dexname 文件到 `/data/`目录下
2. 这个文件的第一行是feature string (这个特征字符串怎么找去ppt里看 "slide.pptx")
3. 文件的第二行是目标app的数据路径，例如 `/data/data/com.test.test/`

**注意**:特征字符会根据加固服务的版本而不同.可以根据logcat查看是否脱壳完成，完成后会生成一个 `wholx.dex`

annotation_off、debug_info_off部分对于程序的执行没什么影响，只会干扰我们脱壳，这部分就忽略掉。作者建议可以写脚本设置这些无效的字段为0.

一些加固会保护很多方法，当被执行前解密还原，在执行完成后擦出。所以要修改 `dvmMterp_invokeMethod`函数去取出当前被执行的指令。

[演示ppt](https://github.com/zyq8709/DexHunter/blob/768fcdc64b89ce468b6f751b0eb124d24e3cde0a/slide.pptx)

[脱阿里加固的演示视频](https://github.com/zyq8709/DexHunter/blob/768fcdc64b89ce468b6f751b0eb124d24e3cde0a/demo.mp4)

### 修改的位置：

[dalvik/Android.mk](http://androidxref.com/4.3_r2.1/xref/dalvik/Android.mk) 这里减了20行 - dalvikvm

[dalvik_system_DexFile.cpp](https://github.com/zyq8709/DexHunter/tree/768fcdc64b89ce468b6f751b0eb124d24e3cde0a/dalvik/vm/native)的目录，可以看到vim编辑的痕迹

[dalvik_system_DexFile.cpp line:335](http://androidxref.com/4.3_r2.1/xref/dalvik/vm/native/dalvik_system_DexFile.cpp)开始添加代码的标记 后面还有一处修改。


首先弄清楚3个问题添加的2段代码是位于哪个函数之中，这个函数什么时候被调用，添加的代码有什么作用？

被添加的代码位 `Dalvik_dalvik_system_DexFile_defineClassNative`函数当中，在这个函数前被添加的代码，都是为了在这个函数中调用的一些函数的声明。

*明天可以百度一下这个函数*

函数注释

> /*
>  * private static Class defineClass(String name, ClassLoader loader,
>  *      int cookie)
>  *
>  * Load a class from a DEX file.  This is roughly equivalent to defineClass()
>  * in a regular VM -- it's invoked by the class loader to cause the
>  * creation of a specific class.  The difference is that the search for and
>  * reading of the bytes is done within the VM.
>  *
>  * The class name is a "binary name", e.g. "java.lang.String".
>  *
>  * Returns a null pointer with no exception if the class was not found.
>  * Throws an exception on other failures.
>  */

翻译过来大概是

> 从dex文件中加载类，大致上等同于VM上的defineClass函数，这个函数被ClassLoader调用去创建一个指定的类。不同点在于，查找和读取字节码的工作在VM中被完成。
> 类名是类似于"java.lang.String"的二进制名
> 如果类没有找到返回空指针，无异常；其他错误引发异常。

推测出这个函数的大致作用是去寻找一个类，并把返回值给第二个参数pResult。

读读这个函数的原版

```

static void Dalvik_dalvik_system_DexFile_defineClass(const u4* args,
    JValue* pResult)
{
    StringObject* nameObj = (StringObject*) args[0];
    Object* loader = (Object*) args[1];
    int cookie = args[2];
    ClassObject* clazz = NULL;
    DexOrJar* pDexOrJar = (DexOrJar*) cookie;
    DvmDex* pDvmDex;
    char* name;
    char* descriptor;

    name = dvmCreateCstrFromString(nameObj);
    descriptor = dvmDotToDescriptor(name);
    ALOGV("--- Explicit class load '%s' l=%p c=0x%08x",
        descriptor, loader, cookie);
    free(name);

    if (!validateCookie(cookie))
        RETURN_VOID();

    if (pDexOrJar->isDex)
        pDvmDex = dvmGetRawDexFileDex(pDexOrJar->pRawDexFile);
    else
        pDvmDex = dvmGetJarFileDex(pDexOrJar->pJarFile);

    /* once we load something, we can't unmap the storage */
    pDexOrJar->okayToFree = false;

    clazz = dvmDefineClass(pDvmDex, descriptor, loader);
    Thread* self = dvmThreadSelf();
    if (dvmCheckException(self)) {
        /*
         * If we threw a "class not found" exception, stifle it, since the
         * contract in the higher method says we simply return null if
         * the class is not found.
         */
        Object* excep = dvmGetException(self);
        if (strcmp(excep->clazz->descriptor,
                   "Ljava/lang/ClassNotFoundException;") == 0 ||
            strcmp(excep->clazz->descriptor,
                   "Ljava/lang/NoClassDefFoundError;") == 0)
        {
            dvmClearException(self);
        }
        clazz = NULL;
    }

    free(descriptor);
    RETURN_PTR(clazz);
}
``` 

最关键 `clazz = dvmDefineClass(pDvmDex, descriptor, loader);`通过这个函数找到一个类，返回类指针


添加的代码大致流程：

```
通过pDvmDex找到odex指针和地址
DexFile* pDexFile=pDvmDex->pDexFile;
MemMapping * mem=&pDvmDex->memMap;

读取前16字节，保存
   const u1 *addr=(const u1*)mem->addr;
                int length=16;
                for (int i=0;i<16;i++) {
                    fwrite(addr+i,1,1,fp);
                    fflush(fp);
                }


// 0. 读取` DexOptHeader`的前16字节到文件
/*
 u1  magic[8];           /* includes version number */
 u4  dexOffset;          /* file offset of DEX header */
 u4  dexLength;
*/
 
addr = (const u1*)mem->addr+16;
                length=int(pDexFile->baseAddr+pDexFile->pHeader->classDefsOff-addr)-16;
                fwrite(addr,1,length,fp);

// 1. 写16字节后，类定义之前部分到文件

                addr = (const u1*)mem->addr+16;
                length=int(
                    pDexFile->baseAddr + 
                    pDexFile->pHeader -> classDefsOff //类定义 
                    -addr)
                -16;
                fwrite(addr,1,length,fp);

// 2. 写类内容到文件
                addr = pDexFile->baseAddr + 
                pDexFile->pHeader->classDefsOff+ 类定义
                sizeof(DexClassDef)*pDexFile->pHeader->classDefsSize;
                
                length=int((const u1*)mem->addr+mem->length-addr); 所有的类数据
                fwrite(addr,1,length,fp);
      
// 创建线程

param.loader=loader;
param.pDvmDex=pDvmDex;
dvmCreateInternalThread(&dumpthread,"ClassDumper",DumpClass,(void*)&param);             

// 线程参数
struct arg{
    DvmDex* pDvmDex;
    Object * loader;
}param;

```

所有的有价值的代码都在线程函数 `DumpClass`中，接着分析

查下 DvmDex的定义 看看注释

```
// 拿到3个参数
Object *loader=((struct arg*)parament)->loader;
DexFile* pDexFile=pDvmDex->pDexFile;
MemMapping * mem=&pDvmDex->memMap;


```
 