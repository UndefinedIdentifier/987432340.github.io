title: 中断请求级IRQL
layout: post
date: 2016-05-12 03:21:07
categories: 读书笔记
tags: 驱动
---

同步机制依赖于中断请求的级别划分(IRQL)，简称中断请求级。和社会的系统类似即使在计算机系统上，也会有严格的等级制度划分，不可能做到绝对的人人平等。

<!--more-->
## 1. IRQL

windows将中断划分为32个中断请求级别，其中0~2是软件中断（优先级低），3~31是硬件中断（优先级高）。硬件的IRQL简称为DIRQL。windows大部分时间运行在软件中断级别中，当设备中断来临时，操作系统提升IRQL到DIRQL，此时系统只接受硬件设备中断，运行相应的中断处理函数。当硬件中断处理完成后，操作系统再把IRQL降回原来的级别。
![](http://7xn4yz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-12%20%E4%B8%8A%E5%8D%882.45.06.png)
用户模式的代码、驱动程序的DriverEntry函数、派遣函数、AddDevice等函数都是运行在PASSIVE_LEVEL级别（最低级别0），在必要时可以申请进入DISPATCH_LEVEL（级别2）。

windows负责线程调度的组件工作在DISPATCH_LEVEL上。想一下，当前线程的时间片假如是1s，那么时钟计时1s，当前线程时间片时间到了，那么系统从PASSIVE_LEVEL提升到DISPATCH_LEVEL，执行线程调度的组件；线程切换完成过后，再降低到PASSIVE_LEVEL。

后面提到的函数StartIO，DPC也运行在DISPATCH_LEVEL上。

```cpp
KeGetCurrentIrql()		//获取当前IRQL
```



## 2. 线程优先级

反正我觉得书上没写太明白啥是线程优先级，就知道线程优先级和IRQL不同，线程优先级只是有更多的机会被调度，但是应用程序IRQL还是都在PASSIVE_LEVEL上。

## 3. IRQL变化

总结如下：

1. 低优先级的中断会被高优先级的中断打断，并提升IRQL到高优先级中断的级别
2. 低优先级不会打断高优先级，必须等高优先级的中断处理函数执行完成后，IRQL降低后再看谁是最高优先级的中断，就处理谁

## 4.IRQL与内存分页

使用分页内存时，有可能使用的内存在磁盘缓存着，那么这时候找不到内存就会引发页异常，执行异常函数从磁盘中加载内容到物理内存中。页异常只允许出现在PASSIVE_LEVEL级别的程序上，如果在DISPATCH_LEVEL及更高的级别上的IRQL程序上，会带来系统崩溃。书上没说原因，我估计是如果分页了但是异常处理程序的IRQL在PASSIVE_LEVEL+1上，所以在DISPATCH_LEVEL上的程序永远也加载不了分页内存进来，引发崩溃。

所以，驱动程序的StartIO、DPC、中断服务例程都不能用分页内存。



## 5. 改变IRQL

```cpp
VOID RasiseIRQL_Test()
{
	KIRQL oldirql;
	// 确保当前IRQL等于或小于DISPATCH_LEVEL
	ASSERT（KeGetCurrentIrql() <= DIPATCH_LEVEL);
	// 提升IRQL到DISPATCH_LEVEL，并将先前的IRQL保存起来
	KeRaiseIrql(DISPATCH_LEVEL, &oldirql);
	//...
	// 恢复到先前的IRQL
	KeLowerIrql(oldirql);
}
```



发现了一个厉害的[博客](http://blog.csdn.net/chenyujing1234/article/details/7764288)，写了很多驱动开发这本书的笔记，各种高亮关键字，可以参考学习。