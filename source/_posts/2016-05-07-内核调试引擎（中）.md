title: 内核调试引擎（中）
layout: post
date: 2016-05-07 16:41:05
categories: 读书笔记
tags: [内核,调试引擎]
---
在进行后续的笔记之前，觉得书上的内容尽管详尽，但也不必把细枝末节都学去了，学到能"为我所用"的部分就够了。我们的学习方向是了解反外挂会用到内核调试中的哪些函数做hook以防止我们进行内核调试，哪些全局变量做检测是否在调试状态。从目的上来讲，我们要解决的时一调试就蓝屏的情况。

<!--more-->

# 一、内核调试协议

位于被调试系统中的内核调试引擎和调试器通过协议彼此沟通、相互协作完成调试工作。DDK中**Windbgkd.h**包含了协议所用的所有数据结构、常量、简单说明。

# 1. 数据包

二者通信离不开数据包，数据包分3类：

中断包：调试器通知内核调试引擎中断到调试器

信息包：传递调试信息或调试命令

控制包：建立通信连接、控制通信流程



信息包大致是以一个固定格式的包头开始，里面包含一个PachetType枚举值，标识后面不定长的数据包的作用。以及一个ByteCount字段，说明此数据包后面不定长数据包的长度。

控制包是只有信息包固定格式包头部分，但是PachetType有所不同。

----

根据具体的操作，会构造不同结构的数据包进行发送，里面各种数据结构，感觉也不用记录，用到查吧。

这里还有个点是windbg刚打开，连上COM口，会不断发送复位包，而被调试内核接收到这个包后，会将全局变量**KdDebuggerNotPresent**设置为0.

# 二、与内核交互

## 1. 中断到调试器

在收到reset包之后，调试引擎向调试器报告状态变化之前，会调用**KdEnterDebugger**函数来冻结内核。直到收到调试器的回复继续执行命令，再调用**KdExitDebugger**回复内核运行。KdEnterDebugger主要有以下动作：

1. 调用KeFreezeExecution()内核调试支持函数，此函数调用KeDisableInterrupts禁止中断。
2. 锁定调试通信端口
3. 调用KdSave让通信扩展模块保存通信状态
4. 将全局变量**KdEnteredDebugger**设置为真

**注意：**这里的第4点，用来判断是否被调试的关键点

当KdEnterDebugger执行后，整个系统进入一种简单的单任务状态，当前的CPU只执行当前的线程，其他CPU处于冻结状态。

接下来，准备好状态变化信息包的内容，调用KdpSendWaitContinue函数来发送信息包。

## 2. KdpSendWaitContinue

KdpSendWaitContinue是调试引擎和调试器交互对话的函数。先发送状态变化信息给调试器，然后开始循环，循环中等待、处理来自调试器的请求。直到遇到DbgKdContinueApi或DbgKdContinueApi2，这个函数会返回到调用他的函数，后者调用KdExitDebugger，系统就跑起来了。

### 3. KdExitDebugger

虽然根据函数名直译为退出调试器，但是实际上只是当前系统暂时不受调试器的控制，直接跑起来了。如果需要后续还是会中断到调试器的。如果想再次中断到调试器，调试器发送中断包，调试引擎如何检测到调试器发送的包呢？

### 4. 轮询中断包

为了支持内核调试，系统的**KeUpdateSystemTime**函数会在每次更新系统时间时检查全局变量**KdDebuggerEnabled**来判断内核调试是否被启用，如果为真，调用KdPollBreakIn函数来查看调试器是否发送了中断命令，如果是，调用BdgBreakPointWithStatus触发异常，以便中断到调试器。

那这个KeUpdateSystemTime函数又是谁调用的呢？当系统时钟中断时，会跳去执行这个函数，因为时钟中断发生的非常频繁，所以在这里轮询中断包是高效的。



### 5. 接受、报告异常事件

发生在内核态的异常，KiDispatchException函数会调用全局变量KiDebugRoutine所指向的函数。当调试器引擎被启用时，这个变量的值是KdpTrap函数的地址。所以当异常发生时，控制流到KdpTrap函数，接着调用**KdpReport**函数向调试器报告异常。KdpReport有以下动作：

1. 调用KdEnterDebugger冻结内核其他部分
2. 调用KiSaveProcessorContrlStat保存CPU控制状态
3. 调用KdpReportExceptionStateChange向调试器报告异常状态变化，接着接受、执行调试器命令，直到恢复执行。
4. 调用KiRestoreProcesstorControlState恢复CPU状态
5. 调用KdExitDebugger恢复内核运行




