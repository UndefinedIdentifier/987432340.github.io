title: 自旋锁
layout: post
date: 2016-05-12 11:37:11
categories: 读书笔记
tags: 驱动
---

自旋锁是一种同步机制，保证资源只能被一个线程所拥有。这种保护形象地称作上锁。

<!--more-->
## 1. 原理

Spin Lock(自旋锁)可以用于驱动的同步处理。初始化自旋锁时，处于解锁状态；这时它可以被程序获取，获取后的自旋锁处于锁定状态，不能被再次获取。

如果自旋锁已被锁住，这时有程序申请“获取”这个锁，程序则处于“自旋”状态。所谓自旋状态，就是不停地询问是否可以“获取”自旋锁，我理解为一直在原地打转。

自旋锁不同于线程中的等待事件，在线程中如果等待某个事件（Event），操作系统会使这个线程**进入休眠状态**，CPU会运行其他线程；而自旋锁原理则不同，它不会切换到别的线程，而是**一直让这个线程“自旋”**。因此**对自旋锁占用时间不宜过长**，否则会导致申请自旋锁的其他线程处于自旋，会浪费CPU时间。

驱动程序必须在**低于或者等于DISPATCH_LEVEL**的IRQL级别中使用自旋锁。



## 2. 使用方法

自旋锁一般为了使各派遣函数之间同步，尽量把自旋锁放在设备扩展里，而不要放在全局变量中。自旋锁使用KSPIN_LOCK数据结构表示，定义自旋锁：

```cpp
typedef struct _DEVICE_EXTENSION
{
	.....
	KSPIN_LOCK My_SpinLock; // 在设备扩展中定义自旋锁
}DEVICE_EXTENSION, *PDEVICE_EXTENSION;
```

使用自旋锁首先需要对其进行**初始化**，可以使用KeInitializeSpinLock内核函数。一般是在驱动程序的DriverEntry或AddDevice函数中初始化自旋锁。

申请自旋锁可以使用内核函数**KeAcquireSpinLock**，它有两个参数，一个为**自旋锁指针**，第二个参数保存获得自旋锁以前的IRQL级别。

```cpp
PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)pDevObj->DeviceExtension;
KIRQL oldirql;
KeACquireSpinLock(&pdx->My_SpinLock, &oldirql);
```

如果在DISPATCH_LEVEL级别申请自旋锁，不会改变IRQL级别。这时，简单使用**KeAcquireSpinLockAtDpcLevel函数**，而释放自旋锁使用**KeReleaseSpinLockAtDpcLevel函数**.



