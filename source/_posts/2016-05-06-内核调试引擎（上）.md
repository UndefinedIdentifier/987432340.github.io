title: 2016-05-06-内核调试引擎（上）
layout: post
date: 2016-05-06 21:06:10
categories: 读书笔记
tags: [内核,调试引擎]
---

什么是**kernel debug engine**? 我们要调试系统内核，就需要做到让系统听我们的话，想随时中断下来就要中断下来让我们调试。假如我们让整个系统都中断了，那么被调试系统中谁来接受我们接下来的调试命令呢？windows的做法是独立出一个和正常操作系统运作没有任何关系，专门用来接受我们（调试器）的调试命令的部分，这部分就是内核调试引擎。

windows操作系统的每个系统部件（每个功能类别）有一个简短的名字，**MM**代表内存管理器，**OB**代表对象管理器，**PS**代表进程线程管理，类似地内核调试引擎也有这样一个双字母名字叫做**KD**。

**角色**：内核调试引擎是**调试器**和**被调试内核**的桥梁，类似于**调试子系统**在**调试器和被调试程序**中的扮演的角色。支持内核调试的函数、变量都是**KD开头**。内核调试引擎和调试器之前想要通信，必须有一套约定好的协议。调试器通过协议请求调试引擎帮助他控制目标系统内核，调试引擎通过协议报告系统内核状态给调试器。内核调试引擎为调试器（更具体的说是内核调试器）提供了一套特殊的API — **kdAPI**，调试器使用kdAPI可以以远程调用的方式访问到内核，这种方式类似于应用程序通过win32API访问内核服务。*在这里做一个关于反外挂的思考，因为驱动程序是对于操作系统内核的一个补充，那是不是用于反外挂的驱动程序，可以做到破坏内核调试引擎不能正常的与调试器进行通讯，就可以达到反外挂的目的。*



<!--more-->

# 一、组成

**KD用于让系统内核其他部分来调用的接口函数**：内核调试引擎写好了一些函数，供系统内核在适当的时机进行调用。比如：windows启动过程中调用**KdInitSystem**函数让内核调试引擎初始化；当系统分发异常时会调用**KiDebugRotine**；系统时间更新函数KeUpdateRunTime会调用**KdCheckForDebugBreak**来检查调试器是否发出了中断命令。

**通信函数**：负责和另一台机器上的调试器进行通信的函数，收发数据包等。

**断点管理**：使用数组**KdpBreakpointTable**记录断点

**内核调试API**：通过这个接口向调试器提供观察、分析被调试系统的服务。不过不是直接被调试器调用，而是调试器通过数据包将要调用的api号和承诺书传递给调试引擎，调试引擎调用相应的api。

**系统内核控制函数**：KdEnterDebugger—将OS中断到调试器；KdExitDebugger--恢复系统运行（18.6节中讨论）

**管理函数**：包括启用和禁止内核调试引擎的**KdEnableDebugger函数**和**KdDisableDebugger函数**，以及修改选项的**KdChangeOption函数**。WinDBG工具包中的kdbgctrl工具就是使用这些函数来工作的。

**ETW支持函数**：与ETW机制配合将追踪数据通过内核调试通信输出到调试器所在的主机上。负责这一功能的主要函数是**KdReportTraceData**，其内部又调用另一个函数**nt!KdpSendTraceData**进行真正的数据操作。（神马是ETW机制）

**驱动程序更新服务**：即从主机上读取驱动程序文件来更新被调试系统中的驱动程序。WinDBG的.kdfiles命令就是依赖这一服务而工作的。当系统内存管理器的**MiCreateSectionForDriver**为一个驱动程序分配内存节（Section）时，如果检测到当前**处于内核调试状态**，就会调用调试引擎的**KdPullRemoteFile**函数，后者再使用**KdpCreateRemoteFile**、**KdpReadRemoteFile**等函数完成文件更新工作

**本地内核调试支持**：包括NtSystemDebugControl和KdSystemDebugControl.

# 二、KDCOM



从Windows XP开始，内核调试引擎中的通信部分从NT内核中，被拆分到一个单独的DLL模块中，名为**KDCOM.DLL**。KDCOM、NTOSKRNL二者之间是相互依赖、互相调用。

KDCOM中最重要的就是**KdSendPacket**和**KdReceivePacket**，分别用来发送和接收数据包。系统进入休眠状态时，KdPowerTransition会调用KdD3Transition通知KDCOM；系统被唤醒时KdD0Transition会被调用。KddebuggerInitialize0，KddebuggerInitialize1是KDCOM输出的初始化函数，供windows启动时调用。



# 三、建立连接

内核调试引擎和调试器之间需要通过某种方式先建立好连接才能通信，再根据协议进行调试。连接的方式有串行口、1294(火线)、USB2.0。

常见的内核调试方式也就是网上说的双机调试环境，即实体机调试虚拟机。这种通信的方式是使用**命名管道模拟串行端口**。

windbg的命令行参数有点小技巧，以前不知道。虚拟机重启后windbg就不能继续调试了，要关了windbg重开一个才行。这里提到，给命令行参数的最后加上参数

```cpp
, reconnect
```

这样虚拟机重启windbg就会重新连接上。



# 四、启动选项

```
/debugport=COM1
```

此选项会指定通信端口，COM1表示串行端口1.

```
/NODEBUG
```

禁用内核调试，优先级最高。

如果系统已经无法正常启动，此时想内核调试，可以通过开机F8进高级启动选项的Debugging Mode选项来启用内核调试。



# 五、初始化

内核调试引擎的初始化随着windows的启动过程而进行。初始化分4部分来讲：



-  windows启动

-  第1次调用KdInitSystem

-  第2次调用KdInitSystem

-  阶段1初始化通信扩展模块


## 1. windows启动

开机后，先执行系统固件即bios，bios执行完后来到MBR，MBR执行系统的加载程序即(NTLDR)。完成实模式到32位保护模式，启动分页机制等之后，加载**NTOSKRNL.EXE**及其依赖文件，KDCOM被加载。之后传递一个描述启动选项的数据结构，调用NT内核的EP即**KiSystemStartup**函数。所以这里是系统内核执行的**入口函数**

KiSystemStartup函数的执行过程：

1. 初始化CPU
2. 调用**KdInitSystem**（初始化内核调试引擎）
3. 调用**KiInitializeKernel**(初始化内核)

先说能很快说清楚的3，后面再说2。这个函数会调用**KiInitSystem**来**初始化系统的全局数据结构**，调用**KeInitializeProcess**创建并**初始化Idle进程**，调用**KeInitializeThread**初**始化Idle线程**，调用**ExpInitializeExecutive**()进行所谓的**执行体阶段0初始化**。ExpInitializeExecutive会依次调用执行体各个机构的**阶段0初始化函数**，包括调用MmInitSystem构建页表和内存管理器的基本数据结构，调用ObInitSystem建立名称空间，调用SeInitSystem初始化token对象，调用PsInitSystem对进程管理器做阶段0初始化（稍后详细说明），调用PpInitSystem让即插即用管理器初始化设备链表。

其中进程管理器的阶段1初始化过程中再次调用了KdInitSystem函数，并调用了**KdDebuggerInitialize1**初始化内核调试通信扩展模块

3返回后，**KiSystemStartup**函数将当前CPU的中断请求级别（IRQL）降低到DISPATCH_LEVEL，然后跳转到KiIdleLoop()，退化为Idle进程中的**第一个Idle线程**。



## 2.第1次调用KdInitSystem

初始化**调试器数据链表**，变量**KdpDebuggerDataListHead**指向这个链表（先初始化链表，把链表的取地址赋值给这个变量）

初始化数据结构**KdDebuggerDataBlock**，调试器需要这里面的信息了解目标操作系统(该结构包括内核基地址、模块链表指针、调试器数据链表指针)

根据KiSystemStartup函数的参数（即：启动选项参数找调试相关的选项）寻找和**调试有关的参数**保存到变量。(**注意**这里的变量是反外挂会关注的点)

调用**KdDebuggerInitialize0**来对通信扩展模块进行阶段0初始化（读到这里我们之前有疑问说：这个过程我们想用vmware双机调试一下，现在看来是做不到了，因为这时候通信模块才刚刚加载，之前的那些过程肯定看不到咯）。如果使用的是串行通信方式，KDCOM中的KdDebuggerInitialize0函数会调用模块内的KdCompInitialize函数来初始化串行口（如果是）。成功初始化COM口后，都会设置HAL模块中所定义的KdComPortInUse全局变量。（这个变量也是检测点咯？）



```
调试相关的选项变量
KdPitchDebugger：布尔类型，用来标识是否显式抑制内核调试。当启动选项中包含/NODEBUG选项时，这个变量会被设置为真。

KdDebuggerEnabled：布尔类型，用来标识内核调试是否被启用。当启动选项中包含/DEBUG或/DEBUGPORT而且不包含/NODEBUG时，这个变量会被设置为真。

KiDebugRoutine：函数指针类型，用来记录内核调试引擎的异常处理回调函数，当内核调试引擎活动时，它指向KdpTrap函数，否则指向KdpStub函数。

KdpBreakpointTable：结构数组类型，用来记录代码断点，每个元素为一个BREAKPOINT_ENTRY结构，用来描述一个断点，包括断点地址。

当使用串行通信方式时，在KDCOM.DLL中定义了两个变量（用来标识下一个要发送/接受的数据包ID）KdCompNextPacketIdToSend和KdCompPacketIdExpected。
```



## 3.第2次调用KdInitSystem

在执行体的阶段1初始化过程中，系统会第二次调用KdInitSystem。

```
kd> kn
# ChildEBP RetAddr  
00 f8958840 8068b0ee nt!KdInitSystem // 内核调试引擎初始化
01 f8958dac 8057c73a nt!Phase1Initialization+0x410 // 执行体的阶段1初始化
02 f8958ddc 805124c1 nt!PspSystemThreadStartup+0x34 // 系统线程启动函数
03 00000000 00000000 nt!KiThreadStartup+0x16 // 内核态的线程启动函数
```



只是简单的调用KeQueryPerformanceCounter来对变量KdPerformanceCounterRate（性能计数器的频率）初始化，然后返回。

## 4. 阶段1初始化通信扩展模块

在阶段1初始化中，系统会调用通信扩展模块的KdDebuggerInitialize1函数来让通信扩展模块得到阶段1初始化的机会。

```
kd> kn
# ChildEBP RetAddr  
00 f8958844 8068b313 kdcom!KdDebuggerInitialize1 // 内核调试通信扩展模块
01 f8958dac 8057c73a nt!Phase1Initialization+0x69a // 执行体的阶段1初始化
02 f8958ddc 805124c1 nt!PspSystemThreadStartup+0x34 // 系统线程的启动函数
03 00000000 00000000 nt!KiThreadStartup+0x16 // 内核态的线程启动函数
```

目前的KDCOM实现会调用KdCompInitialize1，但是只执行很少的操作就返回了。