---
layout: post
title: '《自制编程语言》阅读笔记 - 开篇'
date: 2016-03-31 02:53:07
categories: 读书笔记
tags: 编译原理
---
这一部分阅读内容包括此书的第一章以及前言部分，主要目的是弄清楚这本书的脉络，有的放矢的去阅读整本书。

<!--more-->

# 译者序

鼓励我们创造一门语言并不是想象中那么困难，只要一些C语言基础，正则表达式，不断思索的大脑，就能完成这项工作。译者翻译完之后想到创造一门以文言文为基础的编程语言，把什么易经八卦之类也做成一门语言。译者能有这一想法，说明他在进行翻译此书时，的确是从书中领悟到了什么，我希望自己也能获得超出书本以外的感受、体会。

# 前言

作者说

> 教科书中的理论知识很多，像有限状态机，NFA，LR(1)，等专业词汇非常难读懂（我觉得主要是枯燥无味），这本书注重实践避免枯燥的理论。在我看来，学习完实践之后再来看看理论还是相当不错的。

此书有源代码，在网上可以下载的到。

这本书制作2门语言：`crowbar` 和 `diksam`。这2种语言都具备四则运算、变量、条件分支、循环、函数、垃圾回收等功能；最终版可以支持面向对象、异常处理等高级机制。(没有多线程)唯一不同点在于

> crowbar是运行分析树的无类型语言
>
> dikasmhi运行字节码的静态类型语言。

这两种语言的包括现代的编程语言所必备的高级功能。作者说包教包会，我拭目以待。并且作者说在制作编程语言的过程中他体会到了快乐。

# 第一章

## 为什么要制作编译语言？

作者提出了这个问题，给出了很多理由，但是在这儿我有我个人的一些看法。

可能读这本书之前我认为是要做编译器呢，仔细一体会制作编译语言不等于写编译器，有很多不需要编译的解释性语言。但是既然开始了一件事情，我们就应该好好的把他完成好，尤其是在对一个领域很陌生的时候，你要做的只是多读书。

再往前问问自己，为什么想要写编译器呢？原因很简单，我想做一个在二进制方面的底层hacker，显然写出一个编译器对写反编译器的理解就会更加深刻，并且这是一件很酷的事情。

应该说还没读这本书，但是作者乐观积极的心态应该是绝大多数“程序员”的楷模。另外，我所理解的程序员是一种更加古老的程序员形象，知其然知其所以然的那种类型黑客的感觉；而不是现在在培训班学一个学期出来就能找到一份工作就能自称程序员的那种程序员。

## 赋值语句在自制编程语言中会有哪些需要处理的问题

在书中的1.2节并不叫这个小标题，我改了，认为这个标题更贴切一点。



赋值语句

```cpp
a1 = b1 + b2 * 0.5;	
```

在自制编程语言时要考虑的几个问题：

1. 解析a1,b1,b2作为变量名.怎么解析变脸名？按照语法规则中`变量由xxx开头，由xxx组成`去扫描这句话，将符合条件的部分提取出来。
2. 0.5这样的常量怎样解析？00.2肯定是不行的，把这个过滤掉；2没有小数点也要解析出来。解析常量的难度在于不多不少刚刚好解析出来正确语法的常量。
3. 乘法比加法有更高的优先级，要保证解析出来是b1 + (b2 * 0.5)，而不是(b1 + b2) * 0.5.对于运算符要考虑到优先级。

作者给出了问题的解决方案，也是常规的解决方案。问题1，2用lex解决，问题3用yacc解决。

## 整书脉络

- 第2章：制作计算器。介绍yacc/lex
- 3-4章：制作`crowbar`无类型解释型语言
- 6-8章：制作`diksam`支持静态类型的编译型语言
- 第5章：对编程语言中的中文支持和unicode编码问题做出说明
- 第9章：阐述闭包，异常处理机制等进阶功能

## 要制作怎样的语言

### 语法风格

语法风格大部分和C语言相同，小部分有所改变，相信再遇到实际问题时作者会给出说明，不然就回头来看好了。编写一门新的语言使用的也是C语言，太符合我的心意了。

将if语句的花括号设置为不可省略

改进switch…case语句忘了break就会进入下一case分支



### 要设计怎样的运行方式

> 语言分为解释型语言，编译型语言

作者使用**解释型语言**作为书中的例子。然而解释性语言的实现还可以更加细分。其中一类是将`代码文字`转换成分析树或者语法分析树。

对于这样的代码

```cpp
if(a==10){
    printf("hoge\n");
} else {
    printf("piyo\n");
}   
```

> 有趣的是，英语国家喜欢用foo，bar；而日本喜欢用hoge，piyo来输出无意义的语句。我把这理解为属于程序员的地域习俗。



或者更直白地说对代码这样的字符文本，都会把代码转换成分析树

![](http://7xn4yz.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-03-31%20%E4%B8%8A%E5%8D%882.28.53.png)



从源码到分析树的过程，还得称为“编译”，虽然不是真正的编译。这个过程不生成文件，分析树仅仅在内存里，所以用户意识不到有编译器在执行。这类语言会在刚开始运行就报错。而如果是纯粹性的解释型语言，则会到出错的地方才会报错。

第一种`crowbar`语言的实现是代码转换到语法分析树后直接运行。



java语言是通过解释器运行字节码，而不是运行树，感觉像是运行树经过压缩便成了字节码。第二种`diksam`语言是运行字节码，不是生成树。而我们的语言在程序启动时编译出字节码在内存中，然后直接执行，不像java能产生class文件。

# 环境搭建

编译器：我这里使用ubuntu系统，自带GCC。yacc使用GNU项目下地bison代替。

lex使用加强版的flex代替。





