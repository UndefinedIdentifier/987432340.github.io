title: 调试器栈回溯如何实现
date: 2015-11-18 23:53:33
categories: 杂七杂八
tags: [调试器, 栈]
---

去面试被问到一个问题，

> 调试器是怎么实现栈桢回溯的?

<!--more-->

这个问题应该是属于**基础**的问题，可是当时答的不好，可能是好久都没有看代码了，已经脑子僵化了，今天回来有兴致google了一下具体的方法.

总结来讲：分2类情况谈论，具体情况是，编译器在编译的过程中，是否有做过优化，再具体而言，就是ebp是否是指向 *栈桢* 。

通常一个函数的开头是

``` cpp
push ebp
mov ebp,esp
```
当这两句执行完之后，栈上的情况如下：

```cpp
局部变量 1
局部变量 2
…… ……
局部变量 n
push进来的ebp
函数的返回地址
参数 1
参数 2
参数 3
… …
参数 n
```

在编译器没有优化的时候，是这种情况，这个时候，返回地址实际上就是 `[ebp+4]`

找到一段代码

```
void Debug::TraceStackTrace(unsigned int MaxFrames)
{
	 // Stack contains:
    //  Second function argument 类方法，this指针
    //  First function argument (MaxFrames) 第一个函数参数
    //  Return address in calling function  返回地址
    //  ebp of calling function (pointed to by current ebp) ebp指针

    unsigned int * ebp = &MaxFrames - 2; 
    //MaxFrames 取地址是指针，-2 就是 -8
    //通过这个函数的参数，找到当前函数的栈桢ebp
    //同时，这个参数的值也能表示要找几层栈桢
    Trace("Stack trace:\n");
    for(unsigned int frame = 0; frame < MaxFrames; ++frame)
    {
        unsigned int eip = ebp[1]; //找到函数返回地址
        if(eip == 0)
            // No caller on stack
            break;
        // Unwind to previous stack frame
        // 找到上一层的栈桢ebp
        ebp = reinterpret_cast<unsigned int *>(ebp[0]);
        unsigned int * arguments = &ebp[2];
        Trace("  0x{0:16}     \n", eip);
    }
}
```

还有一种情况是编译器已经优化了代码，或者说写代码的人使用了非默认的编译选项，这种情况就应该使用调试信息，符号表什么的。这种情况在参考链接的讨论页面有所讨论到。


参考链接: [http://wiki.osdev.org/Stack_Trace](http://wiki.osdev.org/Stack_Trace)